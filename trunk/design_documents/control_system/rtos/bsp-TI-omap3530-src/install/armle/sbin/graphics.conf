begin khronos

  egl-dlls = [IMG%s] libsrv_um.so libpvr2d.so libIMGegl.so
  glesv1-dlls = libsrv_um.so libIMGegl.so libImgGLESv1_CM.so
  glesv2-dlls = libsrv_um.so libIMGegl.so libImgGLESv2.so
  vg-dlls = libsrv_um.so libIMGegl.so libImgOpenVG.so
  wfd-dlls = libWFDdevg.so

  begin display
    display-id = 1
    gf-device = 0
    gf-display = 0
  end display

end khronos

begin winmgr
  ##############################################################################
  ##############################################################################
  # Global section
  #
  # This section includes configuration items that have a global reach.
  # They are not tied to a particular display, window class, or input
  # device. It is not necessary for the sections to be in a particular order.
  #
  # begin globals
  #  id = [0..99]
  #    Specifies the id of the composition manager. This id is appended to the
  #    device name that will be created. For example, if id is set to 0, the
  #    composition manager will handle requests sent to /dev/winmgr:0.
  #    It is recommended that you keep this directive out and use the default
  #    id. This default id will ensure that EGL connections established with
  #    EGL_DEFAULT_DEVICE_ID don't return with an error. The value for id must
  #    be a numer between 0 and 99.
  #
  #  autofocus = [on|off]
  #    Sets the focus policy when windows are created or destroy. When autofocus
  #    is on, focus is assigned to newly created windows when they are on top.
  #    Focus will also be assigned to the window above any window that gets
  #    destroyed while it has input focus. The focus goes to the window below
  #    top-most windows that get destroyed while they have input focus. Turning
  #    autofocus off removes these rules and requires a click or refocus from
  #    the window manager. The default value is on.
  #
  #  input = [all|<attach_string>|none]
  #  <attach_string> = <devi_input_device> *
  #  <devi_input_device> = [touch<index>|mouse<index>|keyboard<index>|control<index>]
  #  <index> = [0..15]
  #
  #  pointer-qsize = [auto|1..]
  #    Sets the size of queues allocated to hold pointer events. Depending on
  #    system load and performance, pointer events may start queueing up in the
  #    input driver. When this is the case, it is important to rapidly empty
  #    events from this queue to minimise the latency between events, and cursor
  #    updates, and the actual pointer movements. The value of this property
  #    determines the maximum number of events that can be read at once. The
  #    value of auto indicates that the composition manager is to grow the
  #    queue as events start queueing up. The default value is 1.
  #
  #  queue-incr-size = [size]
  #    Indicates by how much event queues should be grown when an event needs
  #    to be enqueued and the queue is full. The value must be positive and
  #    non-zero.
  #
  #  queue-start-size = [size]
  #    Sets the size of event queues when they are created. If queue-start-size
  #    is set to 20, a queue with 20 events will be allocated for each new
  #    connection that gets established.
  #
  #  select-up-alpha-test = [on|off]
  #
  #  window-incr-size = [size]
  #    This is the amount by which the window pool is grown when it becomes full.
  #
  # end globals

  begin globals
    input = all
    #pointer-qsize = auto
  end globals

  ##############################################################################
  ##############################################################################
  # Display sections
  #
  # There must be one display section for every display that should be handled
  # by the composition manager. A display entry in this configuration file will
  # usually correspond to an actual physical display. When multiple displays are
  # present on a system, the OpenWF display directives must be used to allow the
  # composition manager to target each display. Otherwise, a single EGL display
  # can be used.
  #
  # begin display
  #  id = [int]
  #    Specifies the id of this display instance. This id corresponds to the
  #    KD_QNX_WINDOWPROPERTY_DISPLAY window attribute that must be used to
  #    make a window appear on a specific display. For example, if id is set
  #    to 10, a window would have to call kdSetWindowPropertyiv with pname set
  #    to KD_QNX_WINDOWPROPERTY_DISPLAY and param pointing to a value of 10
  #    in order to put that window on this display. By default, windows will
  #    be placed on the first display entry in this configuration file, not
  #    on display id 0. The default id is an auto incremented integer that
  #    starts with 0.
  #
  #  egl-display = [EGLNativeDisplayID|default]
  #    Indicates which EGL display the composition manager should be connecting
  #    to. The default value is default, which corresponds to
  #    EGL_DEFAULT_DISPLAY.
  #
  #  wfd-device = [WFDDeviceId|default]
  #    The wfd-device entry associates a display section to a physical display.
  #    The sysres utility can be used to generate a list of WFD devices, ports
  #    and pipelines available on a system. It is not necessary to provide a
  #    wfd-device unless the composition manager must handle multiple displays.
  #
  #  wfd-port = [WFDPortId|default]
  #    This directive indicates which display port should be used to drive the
  #    physical display. The sysres utility can be used to generate a list of
  #    WFD devices, ports, and pipelines available on a system. The default
  #    value corresponds to the first port id returned by WFD.
  #
  #  wfd-mode = [width] x [height] @ [refresh]
  #    Use this directive to change the display mode. This directive is only
  #    necessary if the display mode when starting the composition manager is
  #    not set yet. The width and height arguments indicate the display
  #    resolution. The refresh argument is the update rate in frames per second.
  #    The default value is the current display mode. Note that a specific
  #    display controller may not support all combinations of resolutions and
  #    refresh rates.
  #
  #  begin plane
  #    A display must have at least one plane section. A plane represents a
  #    composition stage.
  #
  #    background = rrggbb
  #      Specifies the background color for a plane. This color will fill regions
  #      not occupied by windows of the lower plane. The default background color
  #      is black, or 000000. Note that certain optimizations are available only
  #      if the background color is black. Planes with no target buffers cannot
  #      have a background color. On planes where source color transparency is
  #      enabled (see source-chroma), the background color directive specifies
  #      the source color that will be interpreted as transparent.
  #
  #    cursor = [sw-square|sw-arrow|hw-arrow|off]
  #      This directive indicates the shape of the cursor, if present. If cursor
  #      is set to sw-square or hw-square, a small square is drawn at the
  #      coordinates of the relative pointer device. The composition manager
  #      will use a hardware cursor if the value is set to hw-arrow. The default
  #      value is off.
  #
  #    egl-config = [string]
  #      When the egl-config directive is present, the composition manager
  #      creates a target surface where composition results can be saved. This
  #      allows several windows to share the same plane. The value of egl-config
  #      specifies which pixel format is used to create the target buffer and
  #      which rendering API will be used to do the compositing. The format of
  #      the configuration string argument is a space or comma separated list
  #      of optional configuration specifiers. These specifiers can be used to
  #      select pixel format, rendering API, multi-sampling, or a specific EGL
  #      configuration id. The syntax of each specifier is as follows:
  #
  #        format = [rgba8888|rgba5551|rgba4444|rgb565]
  #        sampling = [int]x, e.g. 2x
  #        renderer = [native|glesv1|glesv2|vg]
  #        id = [int] (a valid EGL configuration id)
  #
  #      A few examples of a configuration string:
  #        egl-config = native rgba8888 (GF blitting to BGRA8888 format)
  #        egl-config = glesv2 (OpenGL ES 2.0 rendering to lowest depth)
  #        egl-config = vg 12 (OpenVG rendering using config id 12)
  #
  #    level = [EGL Level]
  #      Indicates which framebuffer level a plane's windows should be
  #      displayed on. This will usually correspond to the layer number,
  #      and will be passed to EGL when selecting EGL configurationss.
  #
  #    source-alpha = [on|off]
  #      When turned on, the values from alpha channels are used to blend the
  #      contents of a window with other windows or with the background beneath
  #      it. Blending can still be performed even if this option is not enabled
  #      when a target buffer is available (see egl-config). The option is
  #      ignored if the WFD pipeline does not support source alpha blending.
  #      The source-alpha and source-chroma options should not both be turned on.
  #      The options is also ignored if the plane was tied to a valid WFD
  #      pipeline id.
  #
  #    source-chroma = [on|off]
  #      When turned on, colors that correspond to the background color will be
  #      interpreted as transparent. The option is ignored if the hardware does
  #      not support source color transparency. The source-chroma and
  #      source-alpha options should not both be turned on. The options is also
  #      ignored if the plane was tied to a valid WFD pipeline id.
  #
  #    wfd-pipeline = [WFDPipelineID|default]
  #      This directive associates a plane to a WFD pipeline, or layer. Planes
  #      can be associated to WFD pipelines whether they have target buffers or
  #      not (see egl-config directive). A wfd-pipeline with no egl-config will
  #      be able to support one window. When multiple windows are created on
  #      such planes, only the top-most window is visible. Conversely, planes
  #      with target buffers that are associated to WFD pipelines can support
  #      any number of windows simultaneously. The sysres utility can be used
  #      to generate a list of WFD devices, ports, and pipelines available on a
  #      particular system.
  #
  #  end plane
  #
  # end display

  begin display
    begin plane
      wfd-pipeline = 1
    end plane
    begin plane
      wfd-pipeline = 2
    end plane
    begin plane
      wfd-pipeline = 3
      #cursor = hw-arrow
    end plane
  end display

  ##############################################################################
  ##############################################################################
  # Shader sections
  #

  begin program
    type = solid
    begin vertex source
      attribute vec2 vertex;
      void main(void)
      {
        gl_Position = vec4(vertex, 0.0, 1.0);
      }
    end vertex source
    begin fragment source
      uniform lowp vec4 color;
      void main(void)
      {
        gl_FragColor = color;
      }
    end fragment source
  end program

  begin program
    type = standard
    begin vertex source
      attribute vec2 vertex;
      attribute vec2 texcoord;
      varying mediump vec2 coord;
      void main(void)
      {
        gl_Position = vec4(vertex, 0.0, 1.0);
        coord = texcoord;
      }
    end vertex source
    begin fragment source
      uniform sampler2D src;
      varying mediump vec2 coord;
      void main(void)
      {
        gl_FragColor = texture2D(src, coord);
      }
    end fragment source
  end program

  begin program
    type = stream
    begin vertex source
      attribute vec2 vertex;
      attribute vec2 texcoord;
      varying mediump vec2 coord;
      void main(void)
      {
        gl_Position = vec4(vertex, 0.0, 1.0);
        coord = texcoord;
      }
    end vertex source
    begin fragment source
      #ifdef GL_IMG_texture_stream2
      #extension GL_IMG_texture_stream2 : enable
      #endif
      uniform samplerStreamIMG src;
      varying mediump vec2 coord;
      void main(void)
      {
        gl_FragColor = textureStreamIMG(src, coord);
      }
    end fragment source
  end program

  begin program
    type = global-alpha
    begin vertex source
      attribute vec2 vertex;
      attribute vec2 texcoord;
      varying mediump vec2 coord;
      void main(void)
      {
        gl_Position = vec4(vertex, 0.0, 1.0);
        coord = texcoord;
      }
    end vertex source
    begin fragment source
      uniform sampler2D src;
      uniform lowp float alpha;
      varying mediump vec2 coord;
      void main(void)
      {
        lowp vec4 color = texture2D(src, coord);
        gl_FragColor = vec4(color.rgb, color.a * alpha);
      }
    end fragment source
  end program

  begin program
    type = uyvy
    begin vertex source
      attribute vec2 vertex;
      attribute vec2 texcoord;
      uniform highp float hwidth;
      varying mediump vec2 coord;
      varying highp float scoord;
      void main(void)
      {
        gl_Position = vec4(vertex, 0.0, 1.0);
        coord = texcoord;
        scoord = texcoord.s * hwidth - 0.25;
      }
    end vertex source
    begin fragment source
      uniform sampler2D src;
      varying mediump vec2 coord;
      uniform lowp mat3 conv;
      varying highp float scoord;
      void main(void)
      {
        lowp vec4 vyuy = texture2D(src, coord) - vec4(0.5, 0.0625, 0.5, 0.0625);
        lowp float y = mix(vyuy[1], vyuy[3], 2.0 * fract(scoord));
        gl_FragColor = vec4(conv * vec3(y, vyuy[2], vyuy[0]), 1.0);
      }
    end fragment source
  end program

  begin program
    type = ayuv
    begin vertex source
      attribute vec2 vertex;
      attribute vec2 texcoord;
      varying mediump vec2 coord;
      void main(void)
      {
        gl_Position = vec4(vertex, 0.0, 1.0);
        coord = texcoord;
      }
    end vertex source
    begin fragment source
      uniform sampler2D src;
      varying mediump vec2 coord;
      uniform lowp mat3 conv;
      void main(void)
      {
        lowp vec4 yuva = texture2D(src, coord) - vec4(0.0625, 0.5, 0.5, 0.0);
        gl_FragColor = vec4(conv * vec3(yuva[0], yuva[1], yuva[2]), yuva[3]);
      }
    end fragment source
  end program

  ##############################################################################
  ##############################################################################
  # Window class sections
  #
  # Classes can be used by system integrators to set default values for window
  # properties that can be configured differently from system to system. This
  # works as long as the application itself sets the class property or a
  # delegate does it instead. Each begin and end class directive defines a
  # new class. Note that all fields are optional. Only the fields specified in
  # the class description will actually be copied into their corresponding
  # window property.
  #
  # begin class
  #  name = [string]
  #    Indicates the name of the class. No two classes can share the same name,
  #    as this is how windows will identify them. This string affects the
  #    KD_QNX_WINDOWPROPERTY_CLASS window property if a window wishes to inherit
  #    the values stored in this class.
  #
  #  caption = [string]
  #    Caption string for any window deriving from this class. This property is
  #    not used by the composition manager to provide a title bar. It
  #    affects the KD_WINDOWPROPERTY_CAPTION window property.
  #
  #  delegate = [true|false]
  #    Default value of the delegate flag for windows inheriting from this
  #    class. This affects the KD_WINDOWPROPERTY_DELEGATE window property, when
  #    it is set with kdSetWindowPropertybv and read with kdGetWindowPropertybv.
  #
  #  visible = [true|false]
  #    Default value of the visible flag for windows inheriting from this class.
  #    This affects the KD_WINDOWPROPERTY_VISIBILITY window property.
  #
  #  source-alpha = [true|false]
  #    Default value of the source alpha flag for windows inheriting from this
  #    class. This affects the KD_QNX_WINDOWPROPERTY_SOURCE_ALPHA window
  #    property.
  #
  #  pointer-focus = [true|false]
  #    Specicies that pointer focus will be assigned to any window inheriting from
  #    this class. This affects the KD_QNX_WINDOWPROPERTY_POINTER_FOCUS window 
  #    property.
  #
  #    NOTE: When pointer focus is assigned to a window, general focus cannot be
  #          re-assign via mouse click.
  #
  #  focus = [true|false]
  #    Specifies that general focus will be assigned to any window inheriting from
  #    this class. This affects the KD_QNX_WINDOWPROPERTY_FOCUS window property.
  #
  #  surface-size = [width] x [height]
  #    Speficies a default buffer size for windows deriving from this class.
  #    This affects the KD_QNX_WINDOWPROPERTY_SURFACE_SIZE window property.
  #
  #  source-position = [x], [y]
  #    Specifies a default source position for windows deriving from this class.
  #    This affects the KD_QNX_WINDOWPROPERTY_SOURCE_POSITION window property.
  #
  #  source-size = [width] x [height]
  #    Specifies a default source size for windows deriving from this class.
  #    This affects the KD_QNX_WINDOWPROPERTY_SOURCE_SIZE window property.
  #
  #  window-position = [x], [y]
  #    Specifies a default position for windows deriving from this class. This
  #    affects the KD_QNX_WINDOWPROPERTY_POSITION window property.
  #
  #  window-size = [width] x [height]
  #    Specifies a default size for windows deriving from this class. This
  #    affects the KD_WINDOWPROPERTY_SIZE window property.
  #
  #  alpha = [0..255]
  #    Global transparency value for windows deriving from this class. This
  #    affects the KD_QNX_WINDOWPROPERTY_ALPHA window property.
  #
  #  interval = [0..255]
  #    Default swap interval for windows inheriting from this class. This
  #    field does not correspond to an OpenKODE window property. The swap
  #    interval is otherwise set by calling eglSwapInterval.
  #
  # end class

end winmgr
